
# Simple > Clever

## Anti-Patterns

Quick rule of thumb: simple = _fewer concepts to hold in your head_, not merely fewer lines.
If a “simplification” hides behavior, increases coupling, or makes failures harder to see, it’s not simpler—just **obscured**.

### Simplicity = Less Code
#### so delete error handling
* Smell: Exceptions swallowed, edge cases ignored
* Do instead: Handle errors at the edges with small, explicit handlers and clear error types

#### so one "god" module
* Smell: A single mega class/function that does everything
* Do instead: Keep modules small and cohesive; split by responsibility, not by line count

### Premature Generalization
#### over-DRY deduplicate things that only look alike
* Smell: A generic helper that serves five subtly different call sites
* Do instead: Follow the "rule of three" before abstracting; prefer duplication over the wrong abstraction

#### one framework to simplify all use cases
* Smell: A homegrown mini-framework for today's single scenario
* Do instead: Solve the concrete case; extract a library only after repeated use

### Collapsing Boundaries
* Smell: “Keep it simple” by mixing API, domain, and data access layers.
* Do instead: Maintain thin, real boundaries; they reduce coupling and aid testing.

### Stringly-Typed “Simplicity”
* Smell: Passing `Map<String,Any>`/raw JSON everywhere to avoid models.
* Do instead: Use small, typed DTOs; compilers are free test suites.

### Configuration simplification
#### Hard-coding everything
* Smell: Remove config for “simplicity,” baking assumptions into code.
* Do instead: Provide sane defaults with a tiny override surface.

#### Config explosion
* Smell: Move complexity into a 500-line YAML to “keep code clean.”
* Do instead: Prefer code over excessive config; expose only the 3–5 knobs that matter.

### Flat Project “for Simplicity”
* Smell: No domain boundaries; imports form spaghetti.
* Do instead: Group by domain; encapsulate with clear public APIs.
